# -*- coding: utf-8 -*-
"""h.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ogXNvppY49SAxjqW6gDh2i3eSE0HJQPC
"""

import struct as st
import numpy as np               
                  
MNIST = {'MY_IMGS':'train-images.idx3-ubyte'}
train_imagesfile = open(MNIST['MY_IMGS'],'rb')
train_imagesfile.seek(0)
magic = st.unpack('>4B',train_imagesfile.read(4))
number_of_images,number_of_rows,number_of_columns=st.unpack('>III',train_imagesfile.read(12))
temp=np.asarray(st.unpack('>'+(number_of_images*number_of_rows*number_of_columns)*'B',train_imagesfile.read(number_of_images*number_of_rows*number_of_columns)))
images_array=temp.reshape(number_of_images,number_of_rows,number_of_columns)

print(images_array)

import numpy as np

R=[]
for img in images_array:
  temp=np.array(img.flatten())
  R.append(temp)

#flattend image array
R=np.array(R)

####Supervised Learning FDA Implementation ##############


import struct as st
import numpy as np               
                  
MNIST = {'MY_LABELS':'train-labels.idx1-ubyte'}
train_labelsfile = open(MNIST['MY_LABELS'],'rb')
train_labelsfile.seek(0)
magic = st.unpack('>4B',train_labelsfile.read(4))
number_of_items=st.unpack('>I',train_labelsfile.read(4))
temp=(st.unpack('>'+60000*'B',train_labelsfile.read(60000)))

print(temp)

##here I have divided the pictures according to their labels
classes = [[] for i in range(10)]

for i in range(60000):
  index=temp[i]
  classes[index].append(R[i])
  
for i in range(0,len(classes)):
  classes[i]=np.array(classes[i])
classes=np.array(classes)

S_W = np.cov(classes[0].T)
for i in range(1,10):
  cv = np.cov(classes[i].T)
  
  S_W=S_W+cv

###Making diagonal elements 0 of S
S=np.cov(R.T)
#for i in range(0,784):
#  for j in range(0,784):
#    if i != j:5
#      S[i][j]=0

S_B=S-S_W

import numpy as np 

 
S_W_INV = np.linalg.pinv(S_W.T) 

LHS_MAT = S_W_INV.dot(S_B.T)

from scipy.linalg import eigh

values, vectors = eigh(LHS_MAT)

values=np.flipud(values)
vectors=vectors.T
vectors=np.flipud(vectors)

vect_upd=[]
for i in range(0,9):
  vect_upd.append(vectors[i])
  
vect_upd=np.array(vect_upd)

projected_X = np.matmul(vect_upd,R.T)


projected_X=projected_X.T

####LDA####
##################




classes = [[] for i in range(10)]

for i in range(60000):
  index=temp[i]
  classes[index].append(projected_X[i])
  
for i in range(0,len(classes)):
  classes[i]=np.array(classes[i])
classes=np.array(classes)



cov_array=[]
mean=[]
prior=[]

def mean_calc(group):
  
  mean=[]

  for j in range(0,len(group[0])):
    sum=0
    for i in range(0,len(group)):
      sum =sum+group[i][j]
    sum=sum/len(group)
    mean.append(sum)

  mean=np.array(mean)
  return mean

S1 = (len(classes[0])*np.cov(classes[0].T))/len(R)
mean.append(mean_calc(classes[0]))
for i in range(1,10):
  c= (len(classes[i])*(np.cov(classes[i].T)))/len(R)
  S1=S1+c
  mean.append(mean_calc(classes[i]))


for i in range(0,10):
  prior.append(len(classes[i])/60000)

S_INV=np.linalg.pinv(S1.T)
S_DET=np.linalg.det(S1)


import struct as st
import numpy as np               
                  
MNIST = {'MY_IMGS':'t10k-images.idx3-ubyte'}
test_imagesfile = open(MNIST['MY_IMGS'],'rb')
test_imagesfile.seek(0)
magic = st.unpack('>4B',test_imagesfile.read(4))
number_of_images,number_of_rows,number_of_columns=st.unpack('>III',test_imagesfile.read(12))
#temp=np.asarray(st.unpack('>'+(number_of_images*number_of_rows*number_of_columns)*'B',test_imagesfile.read(number_of_images*number_of_rows*number_of_columns)))
#images_array_test=temp.reshape(number_of_images,number_of_rows,number_of_columns)
temp=np.asarray(st.unpack('>'+(10000*number_of_rows*number_of_columns)*'B',test_imagesfile.read(10000*number_of_rows*number_of_columns)))
images_array_test=temp.reshape(10000,number_of_rows,number_of_columns)


#print(images_array_test)
import numpy as np

S=[]
for img in images_array_test:
  temp=np.array(img.flatten())
  S.append(temp)

#flattend image array for testing
S=np.array(S)

#scaler = StandardScaler()
#scaler.fit(S)

#S=(scaler.transform(S))


S = np.matmul(vect_upd,S.T)


S=S.T


#####Test Data label Extraction####
import struct as st
import numpy as np               
                  
MNIST = {'MY_LABELS':'t10k-labels.idx1-ubyte'}
test_labelsfile = open(MNIST['MY_LABELS'],'rb')
test_labelsfile.seek(0)
magic = st.unpack('>4B',test_labelsfile.read(4))
number_of_items=st.unpack('>I',test_labelsfile.read(4))
temp1=(st.unpack('>'+10000*'B',test_labelsfile.read(10000)))

print(temp1)
print((S_INV))
print((S_DET))

###LDA CODE ####

correct=0


for index in range(0,len(S)):
  G_max=-99999999
  cls=-1
  for i in range(0,10):
    p1=-0.5 * np.log(S_DET)
    t=(S[index]-mean[i])
    
    q=np.matmul(t.T ,S_INV)
    p2=-0.5 *(np.matmul(q.T,t))

    p3= np.log(prior[i])

    G = p1+p2 +p3
    #print(G)
    if(G>G_max):
      G_max=G
      cls=i 
  #print(cls)    
  if temp1[index]==cls:
    #print(cls)
    correct =correct+1

#Accuracy for FDA followed by LDA
Accuracy=correct/10000
print(Accuracy)